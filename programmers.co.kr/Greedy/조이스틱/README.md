모든 알고리즘 문제에서는 상황을 명확하게 인식하고, 시뮬레이션 해보면서 발생할 수 있는 변수들을 확인하는 것이 중요하다고 생각합니다.

Level 2 치고는 추가로 고려해야 할 사항이 몇가지 있어서 어려운 문제 같습니다.

이 문제처럼 agent를 이동시키는 문제, 특히 현 시점에서 어떻게 움직여야 할지 정책을 정하는 문제는, 모든 가능한 변수를 파악하고 올바른 정책을 정하는 것이 중요합니다.  
만약에 확률과 불확정성을 더하면 bayesian filter 같은게 되고, 거기에 과거와 미래 가치에대한 평가, 그리고 그 평가의 정확도를 100% 신뢰할 수 없다는 가정까지 추가하면 강화학습에서나 다룰 문제가 되겠네요.  
알고리즘 문제처럼 확률개념이 없는 확정적인 상황은 흔치 않으니 이 쪽이 오히려 실생활이랑은 연관이 클 것 같습니다.

잡소리는 여기까지만 하고, 이 문제는 직접 시뮬레이션 해보면서 가능한 변수들을 파악하는게 중요합니다.  
"처음에는 한 방향으로 직진하는데, 처음에 왼쪽/오른쪽 중 어느 방향으로 갈지를 선택한다." 라고 생각하고 풀었지만, agent가 중간에 방향을 선회해야하는 경우를 포함하지는 못했습니다.  
예를 들어 'AABAAAAABAA' 같은 경우 2번 B를 만들고 방향을 틀고 8번 B를 만드는 것이 최선의 수입니다. 하지만 단 방향으로 이동하는 정책에서는 최선의 수가 나타나지 않습니다.

두 번째 방법은 "항상 최근접 A가 아닌 지점을 향해서 이동한다" 입니다.  
그러면 위의 예제는 풀 수 있습니다. 하지만, 이 경우에도 역시 "좌우 모두 최근접일 때 어느 쪽을 택해야 하는가"를 결정하지는 못합니다.  
예를들어 'ABBAAAB' 같은 경우 처음에 왼쪽이나 오른쪽이나 1 거리에 'B'가 있습니다.  
이 때 오른쪽으로 먼저 이동할 경우 8만큼 이동해야 풀 수 있는 반면, 왼쪽으로 이동해 1칸 짜리 'B'를 제거하고 다시 오른쪽으로 이동해 2칸짜리 'B'를 제거하면 7턴에 풀 수 있습니다.  

이 때 고려해야 할 점은, "최근접 A가 아닌 지점까지의 거리가 좌우 모두 같을 때, 좌우 A가 아닌 것의 덩어리(?)가 얼마나 작은지" 입니다.  
위의 예제에서 우로 이동하면 나오는 덩어리는 'BB'로 2개 짜리고, 좌로 이동하면 나오는 덩어리는 'B' 1개 짜리입니다.  
그 덩어리를 제거한 뒤에 다시 돌아가야하는 경우가 있다고 생각하면 덩어리의 크기가 작을 수록 유리하기 때문에, 작은 덩어리의 방향으로 이동하는 것이 좋습니다.
