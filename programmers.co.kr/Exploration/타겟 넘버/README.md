처음에는 -1 또는 +1로 시작을 해서 탐색 가지를 늘려나간다.  
각 가지가 가능성이 있는 가지인지를 파악해서 잘라낼지, 계속 탐색할지를 결정하는게 핵심이다.

라고 생각하던 때도 있었다...  
numbers의 최대 길이는 20개이고, 각각 2가지 경우의 수가 있기 때문에 전체 경우의 수는 2^20 = 1,048,576 개이다.  
처음에는 2^20이 1억을 넘길 줄 알고(멍청이) 가지를 잘라내는 최적화를 생각했는데, 딱히 없어도 된다.  
그리고 이건 최적화일 뿐이기 때문에 절대적인 성능 향상은 아니다.(즉 최악의 경우에는 최적화의 의미가 없다.)

### ???

- numbers 순서를 바꿀 수 있는지 문제에서 명확하게 설명하지 않고 있다.
- 방법의 수를 구하는 문제는 대부분 모든 경우에 대해 모두 탐색해봐야한다.(brute force + exploration)

### 방법

- BFS로 가자.
- Q에 맨 첫 값을 +- 로 넣고, 그 다음 숫자의 +-를 넣어준다. (현재 값, 더할 값)
- 현재 값 + 더한 값이 (target + sum(뒤의 값들)) 보다 크거나, (target - sum(뒤의 값들)) 보다 작으면 멈춘다.
- Q에는 (현재 값, 깊이, +-) 를 넣어준다.
- 깊이가 맨 마지막일 때 target과 같아지는 것의 개수를 구한다.
